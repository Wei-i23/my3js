<html>
<head>
<style>
#info {
  position: absolute;
  text-align: center;
  width: 100vw;
}
</style>
<body>
<div id="info">
	<h1 style='color:pink'>Shooting-square</h1>
</div>

<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script type = 'module'>
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()

import * as THREE from 'https://unpkg.com/three/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';


var scene,camera,renderer,controls;
var barrel,pointA,pointB,aframe;
var gun,bullet,bulletVector,gunVector;
var bullets = [],cubes = [];
var speed,angle,clock,vel;
var pos = new THREE.Vector3();
var yaw,pitch,keyboard;
//bomb
var uvoffsetArray = [];
var baseS = 0, baseT = 0;
var counter = 0, sprite;
var sprites = [];
//瞄準
var fovY0, fovY1;
var zoom;
var hudCamera, hudScene;


init();
animate();

function makeBarrel(barrelLength) {
   let barrel = new THREE.Group();
   let _barrel = new THREE.Group();
   
   let barrelBody = new THREE.Mesh (new THREE.CylinderGeometry (2,2,barrelLength,20,1), new THREE.MeshNormalMaterial());
   _barrel.add (barrelBody);
   barrelBody.position.set (0, -barrelLength/2, 0);
   barrel.add (_barrel);
   _barrel.rotation.x = -Math.PI/2;
   barrel.position.set(0,0,-200);
      
   return barrel;
}

function init(){
	keyboard = new KeyboardState();
	scene = new THREE.Scene();

	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setClearColor(0x888888);
	renderer.autoClear = false;
	document.body.appendChild(renderer.domElement);
	
	camera = new THREE.PerspectiveCamera(fovY0,window.innerWidth/window.innerHeight,1,10000);
	camera.position.z = 500;
	hudCamera = new THREE.OrthographicCamera (-20,20,20,-20,-10,10);
	let controls = new OrbitControls(camera,renderer.domElement);
	
	//OrthographicCamera正交攝影機
	//有6個參數，left,right,top,bottom,near = 近端面,far = 遠端面
	
	///瞄準
	fovY0 = 60; // wide
	fovY1 = 10; // zoom
	zoom = false;
	
	hudScene = new THREE.Scene();
	hudScene.add (new THREE.Mesh (new THREE.RingGeometry(12,15,30), new THREE.MeshBasicMaterial({color:'black'})));
	hudScene.add (new THREE.Mesh (new THREE.PlaneGeometry(40,40), new THREE.MeshBasicMaterial({color:'yellow', transparent:true,opacity:0.3})));
	hudScene.add (makeCross());
	
	var light = new THREE.PointLight(0xffffff);
	light.position.set(100,300,200);
	scene.add(light);
	
	var gridxz = new THREE.GridHelper(300,30,'red','white');
	scene.add(gridxz);
	
	
	barrel = makeBarrel (30);	//砲台管的長度
	barrel.position.y = 20;
	scene.add (barrel);
	
	//砲台管
	let stand = new THREE.Mesh (new THREE.CylinderGeometry(5,5,20,20), new THREE.MeshNormalMaterial());
	scene.add (stand);
	stand.position.set(0,10,-200);
	
	var whRatio = window.innerWidth / window.innerHeight;
	var halfH = 10;
	var halfW = whRatio * halfH;
	
	// turning
	yaw = 0;
	pitch = 0;
	barrel.rotation.y = yaw;
	barrel.rotation.x = pitch;
	barrel.rotation.order = 'ZYX';
	  
	pointA = new THREE.Mesh (new THREE.SphereGeometry(3,20,20), new THREE.MeshBasicMaterial({color:'yellow'}));
	//pointA.position.copy (barrel.localToWorld (new THREE.Vector3(0,0,0)));
	pointB = new THREE.Mesh (new THREE.SphereGeometry(3,20,20), new THREE.MeshBasicMaterial({color:'red'}));
	//pointB.position.copy (barrel.localToWorld (new THREE.Vector3(0,0,-30)));
	  
	scene.add (pointA, pointB);
	
	///Gun
	let loader = new THREE.TextureLoader();
	loader.crossOrigin = '';
	var texture = loader.load('https://i.imgur.com/qrxgp1q.png');
	
	var texMat = new THREE.MeshBasicMaterial({
		map: texture,
		alphaTest: 0.5	//透明度
		//side:THREE.DoubleSide
	});
	
	gun = new THREE.Mesh(new THREE.PlaneGeometry(15,5),texMat);
	
	gun.position.set(0, -(halfH - halfW / 10)+3, 0);
	//gun.rotation.z = Math.PI/2;
	gun.rotation.y = -Math.PI;
	
	//子彈的向量
	bulletVector = new THREE.Object3D();
	bulletVector.position.set(0,1,20);
	//槍的向量
	gunVector = new THREE.Object3D();
	gunVector.position.set(0,1,18);
	
	camera.position.set(3,3,-15);
	camera.lookAt(bulletVector.position);
	//gun.add(camera);
	gun.add(bulletVector,gunVector);
	gun.position.y = 8;
	scene.add(gun);
	
	///目標物
	var cube1 = new THREE.Mesh(new THREE.BoxGeometry(10,10,10),
		new THREE.MeshBasicMaterial({
			color:0x003377
		}));
	cube1.position.set(-60,5,0);
	scene.add(cube1);
	
	for(let i=0;i<10;i++){
		let cube = cube1.clone();
		cube.position.set((-1+Math.random()*2)*150,40,(-1+Math.random()*2)*150);
		
		cubes.push(cube);
		scene.add(cube);
		cube.position.y = 5;
	}
	
	//bomb
	setUpOffsetArray();

	// instantiate a loader
	var loaderb = new THREE.TextureLoader();

	// load a resource
	loader.load(
		'https://i.imgur.com/6ePTx6p.png',

    function(texture) {
      // Plane with default texture coordinates [0,1]x[0,1]
		var texMat = new THREE.MeshBasicMaterial({
			map: texture,
			transparent: true, // cutout texture: set transparent: true
			side: THREE.DoubleSide
		});
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		buildSprite(texMat);
    },
    // Function called when download progresses
    function(xhr) {
		console.log((xhr.loaded / xhr.total * 100) + '% loaded');
    },
    // Function called when download errors
    function(xhr) {
      console.log('An error happened');
    }
  );

}

//瞄準
function makeCross() {
	let cross = new THREE.Group();
	
	let geometry0 = new THREE.Geometry();
	geometry0.vertices.push (new THREE.Vector3(-12,0,0), new THREE.Vector3(12,0,0));
	let line0 = new THREE.Line (geometry0, new THREE.LineBasicMaterial({color:'black'}));

	let geometry1 = new THREE.Geometry();
	geometry1.vertices.push (new THREE.Vector3(0,-12,0), new THREE.Vector3(0,12,0));
	let line1 = new THREE.Line (geometry1, new THREE.LineBasicMaterial({color:'black'}));
	
	cross.add (line0, line1);	
	return cross;
}

//shooting
function shoot(){
	if(keyboard.down('space')){
		//create bullet
		let bulletgeometry = new THREE.SphereGeometry(2,32,32);
		let bulletmaterial = new THREE.MeshBasicMaterial({color: 0x000000});
		let bullet = new THREE.Mesh(bulletgeometry,bulletmaterial);
		
		bullet.position.copy(pointB.localToWorld(new THREE.Vector3()));
		//子彈有方向性，所以要有一個點，才能產生向量
		let point = pointA.localToWorld(new THREE.Vector3());
		
		
		scene.add(bullet);
		
		//create direct
		let direction = bullet.position.clone().sub(point).normalize();
		//子彈的陣列儲存資料與方向，因為子彈不只一個
		bullets.push({
			bullet: bullet,
			direction: direction,
		});
	}	
	
}

function onWindowResize() {
	renderer.setSize(window.innerWidth, window.innerHeight);
	whRatio = window.innerWidth / window.innerHeight;
	
	camera.aspect = whRatio;
	camera.updateProjectionMatrix();
	
	halfH = 20;
	halfW = halfW * whRatio;
	
	cameraHUD.left = -halfW;
	cameraHUD.right = halfW;
	cameraHUD.top = halfH;
	cameraHUD.bottom = -halfH;
	cameraHUD.updateProjectionMatrix();
	
	aframe.position.set(0, -(halfH-halfW / 10),0);
	aframe.children[0].geometry = new THREE.PlaneGeometry(2*halfW,2*halfW/10);
	aframe.children[1].geometry = new THREE.CircleGeometry(halfW / 15,30)
}
	
function hudButtonPick (event) {
	// convert to NDC
	let ndcX = (event.clientX / window.innerWidth) * 2 - 1;
	let ndcY = -(event.clientY / window.innerHeight) * 2 + 1;

	// convert to HUD scene coordinate
	let halfW = cameraHUD.right;
	let halfH = cameraHUD.top;
	let xx = ndcX * halfW;
	let yy = ndcY * halfH;

	// button location: (0, - (halfH- halfW/10))
	let buttonCenter = new THREE.Vector2 (0, -(halfH-halfW/10));
	let mouse = new THREE.Vector2 (xx, yy);
	if (mouse.distanceTo (buttonCenter) < halfW/15) 
		console.log ('hit')
	else
		console.log ('miss')

}
///bomb
function setUpOffsetArray(){
	var rowCount = 4;
	var colCount = 8;
	for(var i=0;i<rowCount;i++){
		var row = [];
		for(var j=0;j<colCount;j++)
			row.push(new THREE.Vector2(j*0.125,-0.25*i));
		uvoffsetArray.push(row);
	}
}
function buildSprite(texMat) {

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(-15, -15, 0),
		new THREE.Vector3(15, -15, 0),
		new THREE.Vector3(15, 15, 0),
		new THREE.Vector3(-15, 15, 0)
  );

	var face;
	face = new THREE.Face3(0, 1, 2);
	geometry.faces.push(face);
	face = new THREE.Face3(0, 2, 3);
	geometry.faces.push(face);

	// upper left corner
	var uv0 = new THREE.Vector2(0.0,0.75);
	var uv1 = new THREE.Vector2(0.125,0.75);
	var uv2 = new THREE.Vector2(0.125,1.0);
	var uv3 = new THREE.Vector2(0.0,1.0);
  
	geometry.faceVertexUvs[0].push([uv0, uv1, uv2]);
	geometry.faceVertexUvs[0].push([uv0, uv2, uv3]);

	geometry.computeBoundingSphere();
	geometry.computeFaceNormals();
	geometry.computeVertexNormals();

	sprite = new THREE.Mesh(geometry, texMat);
	//scene.add(sprite);

}
function spriteAnimate(sprite) {
	sprite.body.material.map.offset.copy(uvoffsetArray[sprite.baseS][sprite.baseT]);
  
	sprite.baseT = (sprite.baseT + 1) % 8;
	if (sprite.baseT === 0) {
		if(sprite.baseS+1 === 4)
			scene.remove(sprite.body);
		sprite.baseS = (sprite.baseS + 1) % 4;
	}
}

function animate(){
	
	gun.rotation.y = angle;
	
	
	keyboard.update();
	if (keyboard.down('left')) {
		yaw += 0.05;
	} 
	if (keyboard.down('right')) {
		yaw -= 0.05;
	} 
	if (keyboard.down('up')) {
		pitch -= 0.05;
	}
	if (keyboard.down('down')) {
		pitch += 0.05;
	}
	
	if (keyboard.pressed('Z')) {
		zoom = true;
	} else {
		zoom = false;
	}

	if (zoom) {
		camera.fov = fovY1;
	} else {
		camera.fov = fovY0;  
	}
  
	barrel.rotation.y = yaw;
	barrel.rotation.x = pitch;
  
	pointA.position.copy (barrel.localToWorld (new THREE.Vector3(0,0,0)));
	pointB.position.copy (barrel.localToWorld (new THREE.Vector3(0,0,30)));
	
	//if(gun!=undefined)
		shoot();
	sprites.forEach(function(sprite){
		spriteAnimate(sprite);
		sprite.counter++;
	});
	
	bullets.forEach(function(data){
		//setLength子彈速度
		data.bullet.position.add(data.direction.clone().setLength(10));
	});
	
	//子彈移動
	let x = -1,y = -1;
	for(let i=0; i < bullets.length ; i++){
		//original原本的位置
		let origPosition = bullets[i].bullet.position;
		//next下一個的位置
		let nextPosition = bullets[i].bullet.position.clone().add(bullets[i].direction.clone().setLength(2));
		
		for(let j=0; j < cubes.length ; j++){
			let xMin = -5, xMax = 5;
			let zMin = -5, zMax = 5;
			
			//子彈對目標的世界目標
			//把子彈的座標轉換成目標座標
			let bulletOrigLocalPosition = cubes[j].worldToLocal(origPosition.clone()).clone();
			let bulletNextLocalPosition = cubes[j].worldToLocal(nextPosition.clone()).clone();
			
			let c1 = 0,c2 = 0;
			
			if(bulletOrigLocalPosition.x < xMin)	c1+=1;
			if(bulletOrigLocalPosition.x > xMax)	c1+=2;
			if(bulletOrigLocalPosition.z < zMin)	c1+=4;
			if(bulletOrigLocalPosition.z > zMax)	c1+=8;
			
			if(bulletNextLocalPosition.x < xMin)	c2+=1;
			if(bulletNextLocalPosition.x > xMax)	c2+=2;
			if(bulletNextLocalPosition.z < zMin)	c2+=4;
			if(bulletNextLocalPosition.z > zMax)	c2+=8;
			
			//打中目標
			if(c1 == c2 && c1 == 0){
				x=i;
				y=j;
			}
			else if(c1 & c2 ==0){
				x=i;
				y=j;
			}
		}
		bullets[i].bullet.position.copy(nextPosition);
	}
	
	if(x !== -1 && y !== -1){
		//移除子彈與目標物
		scene.remove(bullets[x].bullet,cubes[y]);
		
		//爆炸
		let copySprite = sprite.clone();
		
		sprites.push({
			body:copySprite,
			baseS:0,
			baseT:0,
			counter:0
		});
		
		copySprite.position.copy(bullets[x].bullet.position);
		scene.add(copySprite);
		
		
		bullets.splice(x,1);
		cubes.splice(y,1);
	}
	
	camera.updateProjectionMatrix();
  
	console.log (zoom);
	
	requestAnimationFrame(animate);
	render();
}
	
function render() {
  renderer.clear(true);
  renderer.render(scene, camera);
  if (zoom) 
  	renderer.render (hudScene, hudCamera);
}

</script>
</body>
</html>

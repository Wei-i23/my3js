<html>
<head>
<style>
#info {
  position: absolute;
  text-align: center;
  width: 100vw;
}
</style>
<body>
<div id="info">
	<h1 style='color:pink'>what do you see</h1>
</div>

<script type ="module">
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()

import * as THREE from 'https://unpkg.com/three/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';

var scene,renderer,camera;
var meshMaterial;
var faces;
var plane,oldColor,number;

init();
animate();

function init(){
	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);	//用來用3D
	camera.position.z = 100;
	scene.add(camera);
	

	renderer = new THREE.WebGLRenderer({antialias:true});	//antialias可以增加抗鉅齒
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x888888);
	document.body.appendChild(renderer.domElement);
	
	let controls = new OrbitControls(camera, renderer.domElement);
	
	var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
    scene.add(gridXZ);
	
	//12345
	var loader = new THREE.TextureLoader();
	loader.crossOrigin = '';
	loader.load('https://i.imgur.com/f2MShYR.png',
		function(texture){
			var texMat = new THREE.MeshBasicMaterial({
				map: texture,
				transparent: true,	//透明度
				side: THREE.DoubleSide
			});
			number = new THREE.Mesh(buildSprite(),texMat); 
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			
			scene.add(number);
			
		},

	
	);
	
	var dice = new THREE.Group();
    scene.add (dice);
	
	
	// only test 3 faces (px, py, pz);
	let px = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.4,side: THREE.DoubleSide}));
	dice.add (px);
    px.rotation.y = Math.PI/2;
    px.position.set (15,0,0);
    
    let py = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.4,side: THREE.DoubleSide}));
    dice.add (py);
    py.rotation.x = -Math.PI/2;
    py.position.set (0, 15,0);
    
    let pz = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0x0000ff, transparent:true, opacity:0.4,side: THREE.DoubleSide}));
    dice.add (pz);
    //pz.rotation.x = -Math.PI/2;
    pz.position.set (0, 0, 15);
    
	
	//other 3 faces
	
	let qx = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xffff00, transparent:true, opacity:0.4,side: THREE.DoubleSide}));
	dice.add (qx);
    qx.rotation.y = Math.PI/2;
	qx.position.set (-15,0,0);
	
	let qy = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.4,side: THREE.DoubleSide}));
	dice.add (qy);
    qy.rotation.x = Math.PI/2;
	qy.position.set (0,-15,0);
	
	let qz = new THREE.Mesh (new THREE.PlaneGeometry (30,30), new THREE.MeshBasicMaterial({color:0xff00ff, transparent:true, opacity:0.4,side: THREE.DoubleSide}));
	dice.add (qz);
    qz.rotation.z = Math.PI/2;
	qz.position.set (0,0,-15);
	
	
    faces = {'px': px, 'py': py, 'pz': pz, 'qx': qx, 'qy': qy, 'qz': qz};
	
	setTimeout(countDown, 0);
	
	
}

function searchFace () {
	var maxDot = -1,which;
	
	//法線向量
	var normals = {px: new THREE.Vector3(1,0,0), py: new THREE.Vector3(0,1,0), pz: new THREE.Vector3(0,0,1), qx: new THREE.Vector3(-1,0,0), qy: new THREE.Vector3(0,-1,0), qz: new THREE.Vector3(0,0,-1)};
	//中心點
	var centers = {px: new THREE.Vector3(15,0,0), py: new THREE.Vector3(0,15,0), pz: new THREE.Vector3(0,0,15), qx: new THREE.Vector3(-15,0,0), qy: new THREE.Vector3(0,-15,0), qz: new THREE.Vector3(0,0,-15)};
  
	let dd, point;
	point = camera.position.clone().sub (centers['px']).normalize();
	if ((dd = normals['px'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'px';
	}
	point = camera.position.clone().sub (centers['py']).normalize();
	if ((dd = normals['py'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'py';
	}
	point = camera.position.clone().sub (centers['pz']).normalize();
	if ((dd = normals['pz'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'pz';
	}
	point = camera.position.clone().sub (centers['qx']).normalize();
	if ((dd = normals['qx'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'qx';
	}
	point = camera.position.clone().sub (centers['qy']).normalize();
	if ((dd = normals['qy'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'qy';
	}
	point = camera.position.clone().sub (centers['qz']).normalize();
	if ((dd = normals['qz'].dot (point)) > maxDot) {
		maxDot = dd;
		which = 'qz';
	}
	return which;
}


/*
function setAllFacesTransparent () {
  faces['px'].material.transparent = true;
  faces['py'].material.transparent = true;
  faces['pz'].material.transparent = true;
  
  faces['qx'].material.transparent = true;
  faces['qy'].material.transparent = true;
  faces['qz'].material.transparent = true;
}
*/
function countDown(){
	
	setTimeout(countDown, 1000);
	
	if(number){
		var texture = number.material.map;
		texture.offset.x -= 0.2;	//控制數字的移動
	}

}

function buildSprite(){
	var geometry = new THREE.Geometry();
	geometry.vertices.push(		//調整動畫大小
		new THREE.Vector3(-10, -10, 0),
		new THREE.Vector3(10, -10, 0),
		new THREE.Vector3(10, 10, 0),
		new THREE.Vector3(-10, 10, 0)
	);

	var face;
	face = new THREE.Face3(0, 1, 2);
	geometry.faces.push(face);
	face = new THREE.Face3(0, 2, 3);
	geometry.faces.push(face);
  
	var uv0 = new THREE.Vector2(0.0,0.0);
	var uv1 = new THREE.Vector2(0.2,0.0);
	var uv2 = new THREE.Vector2(0.2,1.0);
	var uv3 = new THREE.Vector2(0.0,1.0);
  
	geometry.faceVertexUvs[0].push([uv0, uv1, uv2]);
	geometry.faceVertexUvs[0].push([uv0, uv2, uv3]);

	geometry.computeBoundingSphere();
	geometry.computeFaceNormals();
	geometry.computeVertexNormals();
	return geometry;
	
}

function animate() {
	//setAllFacesTransparent();
	
   // go through all faces, determine which one facing camera
	let which = searchFace();
	
	if(number){
		number.position.copy(faces[which].position);
		number.rotation.copy(faces[which].rotation);
		
	}
	requestAnimationFrame(animate);
	render();
}

function render() {
    renderer.render(scene, camera);
}









</script>
</body>
</html>
